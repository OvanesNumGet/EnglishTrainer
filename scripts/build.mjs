import { promises as fs } from 'node:fs';
import path from 'node:path';
import { build as esbuild } from 'esbuild';
import postcss from 'postcss';
import postcssImport from 'postcss-import';
import cssnano from 'cssnano';
import { generateLucideIcons } from './generate-lucide-icons.mjs';

async function rmrf(p) {
    await fs.rm(p, { recursive: true, force: true });
}

async function mkdirp(p) {
    await fs.mkdir(p, { recursive: true });
}

async function copyFile(src, dest) {
    await mkdirp(path.dirname(dest));
    await fs.copyFile(src, dest);
}

async function copyDir(srcDir, destDir) {
    await mkdirp(destDir);
    const entries = await fs.readdir(srcDir, { withFileTypes: true });
    for (const e of entries) {
        const src = path.join(srcDir, e.name);
        const dest = path.join(destDir, e.name);
        if (e.isDirectory()) await copyDir(src, dest);
        else if (e.isFile()) await copyFile(src, dest);
    }
}

function patchIndexHtmlForDist(html) {
    // Use minified CSS
    html = html.replace(/href=["']css\/style\.css["']/g, `href="css/style.min.css"`);

    // Replace main entry with minified bundle (non-module)
    html = html.replace(
        /<script\s+type=["']module["']\s+src=["']js\/main\.js["']\s*><\/script>/g,
        `<script src="js/main.min.js"></script>`
    );

    return html;
}

function getBuildVersion() {
    const sha = process.env.VERCEL_GIT_COMMIT_SHA || process.env.GITHUB_SHA || '';
    if (sha) return `v-${sha.slice(0, 8)}`;
    return `v-${new Date().toISOString().replace(/[^0-9]/g, '').slice(0, 14)}`;
}

function renderServiceWorker({ version }) {
    const coreAssets = [
        './',
        './index.html',
        './manifest.json',
        './css/style.min.css',
        './js/lucide.min.js',
        './js/main.min.js',

        './html/header.html',
        './html/tabs.html',
        './html/settings_menu.html',
        './html/stats.html',
        './html/flashcards.html',
        './html/test.html',
        './html/controls.html',

        './icons/icon.svg'
    ];

    return `// Service Worker (generated by scripts/build.mjs)
const VERSION = ${JSON.stringify(version)};

const PRECACHE = \`ivt-precache-\${VERSION}\`;
const RUNTIME = \`ivt-runtime-\${VERSION}\`;

const CORE_ASSETS = ${JSON.stringify(coreAssets, null, 2)};

function isCacheableResponse(response) {
  return !!response && (response.ok || response.type === 'opaque');
}

async function putInCache(cacheName, request, response) {
  if (!isCacheableResponse(response)) return;
  const cache = await caches.open(cacheName);
  await cache.put(request, response);
}

async function networkFirst(request) {
  try {
    const response = await fetch(request);
    await putInCache(RUNTIME, request, response.clone());
    return response;
  } catch (_) {
    const cached = await caches.match('./index.html', { ignoreSearch: true });
    if (cached) return cached;

    const anyCached = await caches.match(request, { ignoreSearch: true });
    if (anyCached) return anyCached;

    return new Response('Offline', {
      status: 503,
      headers: { 'Content-Type': 'text/plain; charset=utf-8' }
    });
  }
}

async function staleWhileRevalidate(request) {
  const cached = await caches.match(request);

  const fetchPromise = (async () => {
    try {
      const response = await fetch(request);
      await putInCache(RUNTIME, request, response.clone());
      return response;
    } catch (_) {
      return null;
    }
  })();

  if (cached) return cached;

  const network = await fetchPromise;
  if (network) return network;

  return new Response('Offline', {
    status: 503,
    headers: { 'Content-Type': 'text/plain; charset=utf-8' }
  });
}

self.addEventListener('install', (event) => {
  event.waitUntil((async () => {
    const cache = await caches.open(PRECACHE);
    await Promise.allSettled(CORE_ASSETS.map((url) => cache.add(url)));
    await self.skipWaiting();
  })());
});

self.addEventListener('activate', (event) => {
  event.waitUntil((async () => {
    const keys = await caches.keys();
    await Promise.all(
      keys.map((key) => {
        const isOurCache = key.startsWith('ivt-');
        const isCurrent = key === PRECACHE || key === RUNTIME;
        if (isOurCache && !isCurrent) return caches.delete(key);
        return undefined;
      })
    );

    await self.clients.claim();
  })());
});

self.addEventListener('message', (event) => {
  if (event.data === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

self.addEventListener('fetch', (event) => {
  const { request } = event;

  if (request.method !== 'GET') return;
  if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') return;

  if (request.mode === 'navigate') {
    event.respondWith(networkFirst(request));
    return;
  }

  event.respondWith(staleWhileRevalidate(request));
});
`;
}

async function buildCss() {
    const inputPath = path.join('css', 'style.css');
    const outPath = path.join('dist', 'css', 'style.min.css');

    const cssIn = await fs.readFile(inputPath, 'utf8');

    const result = await postcss([
        postcssImport(),
        cssnano({ preset: 'default' })
    ]).process(cssIn, {
        from: inputPath,
        to: outPath
    });

    await mkdirp(path.dirname(outPath));
    await fs.writeFile(outPath, result.css, 'utf8');
}

async function buildJs() {
    await mkdirp(path.join('dist', 'js'));

    // Many npm packages gate code by process.env.NODE_ENV.
    // In browser this can crash as "process is not defined" unless we inline it.
    const defineEnv = {
        'process.env.NODE_ENV': '"production"'
    };

    // 1) lucide.min.js (only used icons)
    await esbuild({
        entryPoints: [path.join('js', 'lucide-entry.js')],
        outfile: path.join('dist', 'js', 'lucide.min.js'),
        bundle: true,
        minify: true,
        format: 'iife',
        globalName: 'lucide',
        platform: 'browser',
        target: ['es2018'],
        legalComments: 'none',
        define: defineEnv
    });

    // 2) main.min.js (whole app)
    await esbuild({
        entryPoints: [path.join('js', 'main.js')],
        outfile: path.join('dist', 'js', 'main.min.js'),
        bundle: true,
        minify: true,
        format: 'iife',
        platform: 'browser',
        target: ['es2018'],
        legalComments: 'none',
        define: defineEnv
    });
}

async function buildHtml() {
    const src = await fs.readFile('index.html', 'utf8');
    const out = patchIndexHtmlForDist(src);
    await fs.writeFile(path.join('dist', 'index.html'), out, 'utf8');
}

async function copyStatic() {
    if (await fs.stat('html').catch(() => null)) await copyDir('html', path.join('dist', 'html'));
    if (await fs.stat('icons').catch(() => null)) await copyDir('icons', path.join('dist', 'icons'));

    await copyFile('manifest.json', path.join('dist', 'manifest.json'));
}

async function buildSw() {
    const version = getBuildVersion();
    const sw = renderServiceWorker({ version });
    await fs.writeFile(path.join('dist', 'sw.js'), sw, 'utf8');
}

async function main() {
    await rmrf('dist');
    await mkdirp('dist');

    // Generate icon list from HTML (auto)
    await generateLucideIcons({ outFile: path.join('js', 'lucide-icons.generated.js') });

    await Promise.all([
        buildCss(),
        buildJs()
    ]);

    await Promise.all([
        buildHtml(),
        copyStatic(),
        buildSw()
    ]);

    console.log('Build complete: dist/');
}

main().catch((e) => {
    console.error(e);
    process.exitCode = 1;
});
