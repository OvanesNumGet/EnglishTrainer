import { promises as fs } from 'node:fs';
import path from 'node:path';

async function exists(p) {
    try {
        await fs.access(p);
        return true;
    } catch {
        return false;
    }
}

async function listFilesRecursive(dir) {
    const out = [];
    const entries = await fs.readdir(dir, { withFileTypes: true });
    for (const e of entries) {
        const p = path.join(dir, e.name);
        if (e.isDirectory()) out.push(...await listFilesRecursive(p));
        else out.push(p);
    }
    return out;
}

function toPascalCaseLucideExport(kebab) {
    // "bar-chart-2" -> "BarChart2"
    // "maximize-2" -> "Maximize2"
    // "party-popper" -> "PartyPopper"
    return kebab
        .split('-')
        .filter(Boolean)
        .map((part) => {
            if (/^\d+$/.test(part)) return part;
            return part.charAt(0).toUpperCase() + part.slice(1);
        })
        .join('');
}

// Lucide icon names in markup are kebab-case
const ICON_NAME_RE = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;

// Extract "real" icon names from a raw captured value.
// Handles cases like:
// - "check"
// - "${iconNames[type] || 'check'}"  -> extracts 'check'
function collectIconNamesFromRaw(raw, iconNamesSet) {
    const s = (raw ?? '').toString().trim();
    if (!s) return;

    // Plain literal icon name
    if (ICON_NAME_RE.test(s)) {
        iconNamesSet.add(s);
        return;
    }

    // Template / expression: try to extract quoted literals inside it
    // e.g. ${foo || 'check-line'} or "${'check'}"
    const quoted = /['"]([a-z0-9]+(?:-[a-z0-9]+)*)['"]/g;
    let m;
    while ((m = quoted.exec(s)) !== null) {
        const name = (m[1] || '').trim();
        if (ICON_NAME_RE.test(name)) iconNamesSet.add(name);
    }
}

export async function generateLucideIcons({
    outFile = path.join('js', 'lucide-icons.generated.js')
} = {}) {
    const iconNames = new Set();

    const filesToScan = [];

    // 1) Static HTML entry
    if (await exists('index.html')) filesToScan.push('index.html');

    // 2) HTML fragments
    if (await exists('html')) {
        const htmlFiles = (await listFilesRecursive('html')).filter((f) => f.endsWith('.html'));
        filesToScan.push(...htmlFiles);
    }

    // 3) JS sources (to catch dynamically injected templates with data-lucide="...")
    if (await exists('js')) {
        const jsFiles = (await listFilesRecursive('js')).filter((f) => f.endsWith('.js'));
        filesToScan.push(...jsFiles);
    }

    // Patterns we support
    const patterns = [
        // Markup attribute
        /data-lucide\s*=\s*["']([^"']+)["']/g,

        // JS assignments
        /dataset\.lucide\s*=\s*["']([^"']+)["']/g,

        // JS DOM setAttribute
        /setAttribute\(\s*["']data-lucide["']\s*,\s*["']([^"']+)["']\s*\)/g
    ];

    for (const file of filesToScan) {
        const content = await fs.readFile(file, 'utf8');

        for (const re of patterns) {
            re.lastIndex = 0;
            let m;
            while ((m = re.exec(content)) !== null) {
                collectIconNamesFromRaw(m[1], iconNames);
            }
        }
    }

    const kebabIcons = Array.from(iconNames).sort((a, b) => a.localeCompare(b));

    // Lucide createIcons() internally maps data-lucide value to PascalCase for lookup.
    // So the icons object MUST be keyed by PascalCase names.
    const exportNames = kebabIcons.map(toPascalCaseLucideExport);

    const header = `// AUTO-GENERATED FILE. DO NOT EDIT BY HAND.
// Generated by scripts/generate-lucide-icons.mjs
// Exports only the icons found in data-lucide="..." attributes across your HTML and JS sources.
// IMPORTANT: Keys are PascalCase because Lucide internally looks up icons by PascalCase.

`;

    let body = '';
    if (kebabIcons.length === 0) {
        body = `export const lucideIcons = {};\n`;
    } else {
        body += `import {\n`;
        body += exportNames.map((n) => `  ${n}`).join(',\n');
        body += `\n} from 'lucide';\n\n`;

        // Object keys are PascalCase identifiers (no quotes)
        body += `export const lucideIcons = {\n`;
        body += exportNames.map((n) => `  ${n}`).join(',\n');
        body += `\n};\n`;
    }

    await fs.mkdir(path.dirname(outFile), { recursive: true });
    await fs.writeFile(outFile, header + body, 'utf8');

    return { iconsCount: kebabIcons.length, outFile };
}

// Allow running directly: node scripts/generate-lucide-icons.mjs
if (import.meta.url === `file://${process.argv[1]}`) {
    generateLucideIcons()
        .then(({ iconsCount, outFile }) => {
            console.log(`Generated ${outFile} (${iconsCount} icons)`);
        })
        .catch((e) => {
            console.error(e);
            process.exitCode = 1;
        });
}
